import pandas as pd
from requests_oauthlib import OAuth2Session
from oauthlib.oauth2 import LegacyApplicationClient
import configparser
from retry_requests import retry
from requests import Session
import os
import json
from datetime import datetime, timedelta
import math
import ast
from sqlalchemy import create_engine
from urllib.parse import quote_plus
import sqlalchemy
from sqlalchemy import exc


"""
    This script loops through the "team_assignment_issues.xlsx" file generated by the
    "check_team_assignments.py" script and tries to set the correct team assignments
    through the OpenSRP API endpoint based on team assignments pulled from Metabase. 

    Note that an active FortiClient VPN connection is a requirement if there are
    any complete plans with team assignment issues. This is due to a bug in OpenSRP
    where complete plans have no end date. Because the team assignments table has a 
    constraint on the duration column that prevents overlapping durations, no new team
    assignments can be assigned unless the team assignments are manually deleted and
    recreated which is handled automatically by the script.
"""


# Create the requests session with retries and backoff
retrySession = retry(Session(), retries=10, backoff_factor=0.1)


def get_oauth_token(config, server):
    token_url = config[f'{server}_reveal']['token_url']
    username = config[f'{server}_reveal']['username']
    password = config[f'{server}_reveal']['password']
    client_id = config[f'{server}_reveal']['client_id']
    client_secret = config[f'{server}_reveal']['client_secret']
    oauth = OAuth2Session(client=LegacyApplicationClient(client_id=client_id))
    return oauth.fetch_token(token_url=token_url,username=username, password=password,client_id=client_id, client_secret=client_secret)


def get_request(url, headers=[]):
    r = retrySession.get(url, headers=headers)
    if r.status_code == 200:
        j = r.json()
        return pd.DataFrame(j)
    else:
        raise ValueError(f'Could not get data from the following url: {url}')


def create_team_assignment_json(idList, planId, jurisdictionId, fromDate, toDate):
    assignArray = []
    for val in idList:
        assignArray.append({
            "organization": val,
            "jurisdiction": jurisdictionId,
            "plan": planId,
            "fromDate": fromDate,
            "toDate": toDate
        })
    return assignArray


def main():

    # Load the config file and get the Oauth2 token
    config = configparser.ConfigParser()
    config.read(os.path.join(os.path.dirname(os.path.realpath(__file__)),'config.ini'))
    token = get_oauth_token(config, 'local')
    revealHeaders = {"Authorization": f'Bearer {token["access_token"]}'}

    # Get the current orgs from the API
    orgUrl = 'https://servermhealth.ddc.moph.go.th/opensrp/rest/organization'
    orgs = get_request(orgUrl, revealHeaders)

    # Load the issues and filter out already fixed issues
    df = pd.read_excel('./team_assignment_issues.xlsx')
    df = df[df['fixed'] == False]
    # df = df[df['identifier'] == 'e1562ed8-0dac-41a7-8bb9-9b627b0ee0ef']
    df = df.reset_index()
    # dfEmpty = df[df.api == '[]']
    # dfEmpty = dfEmpty.reset_index()

    # If any of the team assignment issues are for completed plans, connect to the OpenSRP database
    if any(df.status == 'complete'):
        usr = config['canopy']['username']
        pwd = config['canopy']['password']
        svr = config['canopy']['server']
        db = config['canopy']['database']
        engine_string = f'postgresql+psycopg2://{usr}:{quote_plus(pwd)}@{svr}/{db}'
        canopy = create_engine(engine_string)

    # Loop through the dataframe and push new assignments
    for index, row in df.iterrows():

        print(f'{index + 1}/{len(df)}: Fixing team assignments for planID {row.identifier} with status {row.status}...')

        # Evaluate the rows into Python lists
        correctNamedAssignments = ast.literal_eval(row.correct)
        apiNamedAssignments = ast.literal_eval(row.api)

        # Get the values that are missing from the current team assignments
        missingNamedAssignments = list(set(correctNamedAssignments) - set(apiNamedAssignments))
        # extraNamedAssignments = list(set(apiNamedAssignments) - set(correctNamedAssignments))
        
        # # Loop through assignment names and get the correct IDs for each organization
        idAssignments = [orgs[orgs.name == name.strip()].identifier.values[0] for name in missingNamedAssignments]

        # Set the dates - fromDate is from the effectivePeriod_start value and toDate is 5 years in the future
        fromDate = math.floor((row.effectivePeriod_start.timestamp()) * 1000)
        toDate = math.floor(((row.effectivePeriod_start + timedelta(days=5*365)).timestamp()) * 1000)

        # Create the team assignment JSON
        j = create_team_assignment_json(idAssignments, row.identifier, row.jurisdiction, fromDate, toDate)
        # print(json.dumps(j, indent=2))

        # For complete plans, manually delete the team assignments from OpenSRP before proceeding
        if(row.status == 'complete'):
            sql = f'''
                delete from team.organization_location
                where id in (
                    select team.organization_location.id
                    from team.organization_location
                    left join core.plan on core.plan.id = team.organization_location.plan_id
                    where identifier = '{row.identifier}'
                )
            '''
            try:
                canopy.execute(sql)
            except exc.SQLAlchemyError:
                print('    Failed to connect to OpenSRP database. Is the FortiClient VPN connected?')


        assignUrl = 'https://servermhealth.ddc.moph.go.th/opensrp/rest/organization/assignLocationsAndPlans'
        r = retrySession.post(assignUrl, json=j, headers=revealHeaders)
        if r.status_code != 200:
            # raise ValueError(f'Response code from the server: {r.status_code}')
            print(f'    Failure with status code {r.status_code}')

        

if __name__ == '__main__':
    main()
    